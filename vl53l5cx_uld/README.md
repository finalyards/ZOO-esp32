# `v53l5cx_uld`

Turns the `VL53L5CX_ULD_API` source code into something that can be used in Rust applications.

>Note: Usually Rust/C bindings are done in two layers: a `-sys` library forming a 1-to-1 bridging to C code, and another library adapting the use for Rust.
>
>We *kind of* have this approach, by having a a `src/uld_raw.rs` generated by `bindgen` from C sources. But these are in the one Rust module, not two separate.
>Currently, we are keeping everything together (for simplicity); depends on the amount of Rust adaptation.

**The one thing this level doesn't do is *be aware of Embassy* in any way (`async/.await`).**

## Pre-reading

- ["Using C Libraries in Rust"](https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a) (blog, Aug '19)

   A bit old, but relevant (C API's don't age!).
   
## The job

![](.images/bindgen-jumps.png)

><font color=orange>*tbd. CHANGES TO THE IMAGE ARE LIKELY!*</font>


## Requirements

See hardware and software requirements -> [`../README`](../README.md).

### `bindgen`

Install dependencies:

```
$ sudo apt install llvm-dev libclang-dev clang
```

```
$ cargo install bindgen-cli
```

>Note: Bindgen docs recommend using it as a library, but we prefer to use it as a command line tool.


## Preparation

### The vendor C libary

The [VL53L5CX_ULD library](https://www.st.com/en/embedded-software/stsw-img023.html) is a separate download.

1. Fetch it from ST (link above)
2. Unzip and place it to `./VL53L5CX_ULD_driver_2.0.0`

	Note that while you need to `Agree` to the larger ST.com license, it has the clause: 
	
	>Open Source Software [...] is not subject to the terms of this PLLA to the extent [...]
	
	Overall, the ST.com licensing seems awkward to the author; that's why I'm leaving this part to you!  In practise, the above part is likely BSD 3-clause, but the process doesn't make it at all clear!!! **@ST.com: please, you can improve upon this.**


### Supported dev kits

The workflow has been tested on these MCUs:

|||
|---|---|
|`esp32c3` (default)|[ESP32-C3-DevKitC-02](https://docs.espressif.com/projects/esp-idf/en/stable/esp32c3/hw-reference/esp32c3/user-guide-devkitc-02.html) dev kit, with JTAG/USB wiring added|
|`esp32c6`|[ESP32-C6-DevKitM-01](https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32c6/esp32-c6-devkitm-1/user_guide.html)|
|`esp32`|[Adafruit ESP32 Feather V2](https://www.adafruit.com/product/5400); use a separate branch `adafruit-feather-v2`|

Between RISC V variants, the code allows you to change targets rather easily, back and forth. To do this, run `./set-target.sh` .

### Wiring

See [WIRING](./WIRING.md) for how you are expected to wire a single SATEL board to your MCU.

### Using multiple boards

See [Working with multiple boards](./Working%20with%20multiple%20boards.md) if you intend to have multiple sensors. There are some hoops involved in that setup.


## Compiling 

```
$ cargo build --release --lib
```

This compiles the library, and is a good place to start. 

>One thing to note about the library is that it's fully hardware agnostic; this is something we inherit from the approach of the vendor ULD C API. *Your code* (represented by `examples/` in this repo) brings in, for example, how to drive the I2C bus.

<span />

>The command uses `Makefile` internally. If there are problems with the build, you may want to run the Makefile separately (see below).
>
>```
>$ make src/uld_raw.rs tmp/libvendor_uld.a
>```

Likely you are more interested in the runnable samples, though. Let's have a look!

## Running samples

Running a sample expects that you have a device accessible via `probe-rs`:

```
$ probe-rs list
The following debug probes were found:
[0]: ESP JTAG -- 303a:1001:54:32:04:41:7D:60 (EspJtag)
```

```
$ cargo run --release --features=targets_per_zone_2,ambient_per_spad,nb_spads_enabled,signal_per_spad,range_sigma_mm,distance_mm,reflectance_percent,defmt --example m2
[...]
      Erasing ✔ [00:00:02] [######################] 256.00 KiB/256.00 KiB @ 98.28 KiB/s (eta 0s )
  Programming ✔ [00:00:47] [######################] 104.38 KiB/104.38 KiB @ 2.21 KiB/s (eta 0s )    
  Finished in 47.16089s
0.848963 [INFO ] Target powered off and on again.
0.852650 [DEBUG] Ping succeeded: 0xf0,0x02
3.621574 [INFO ] Init succeeded, driver version VL53L5CX_2.0.0
4.007674 [INFO ] Data #0 (sensor 36°C)
...
5.386734 [INFO ] Data #9 (sensor 35°C)
5.386766 [INFO ] .target_status:    [[[Valid(5), Valid(5), Valid(5), Valid(5)], [Valid(5), Valid(5), Valid(5), Valid(5)], [Valid(5), Valid(5), Valid(5), Valid(5)], [Valid(5), Valid(5), Valid(5), Valid(5)]], [[Valid(5), Other(4), Other(0), Other(0)], [Other(0), Other(4), Other(4), Other(0)], [Other(0), Other(2), Other(0), Other(4)], [Other(0), Other(0), Other(4), Other(0)]]]
5.386989 [INFO ] .targets_detected: [[2, 1, 1, 1], [1, 1, 2, 1], [1, 1, 1, 1], [1, 1, 1, 1]]
5.387078 [INFO ] .ambient_per_spad: [[1, 0, 0, 1], [1, 2, 1, 0], [1, 2, 1, 1], [1, 1, 1, 1]]
5.387188 [INFO ] .spads_enabled:    [[16128, 15872, 15104, 15872], [15104, 15104, 15872, 14848], [15616, 14848, 15616, 15104], [15360, 15360, 15872, 15360]]
5.387302 [INFO ] .signal_per_spad:  [[[3, 15, 13, 13], [18, 17, 14, 12], [18, 16, 16, 11], [18, 15, 14, 13]], [[11, 11, 0, 0], [0, 2, 8, 0], [0, 2, 0, 2], [0, 0, 2, 0]]]
5.387497 [INFO ] .range_sigma_mm:   [[[28, 8, 8, 10], [7, 6, 7, 10], [7, 6, 8, 12], [6, 7, 8, 12]], [[15, 9, 0, 0], [0, 39, 7, 0], [0, 52, 0, 47], [0, 0, 46, 0]]]
5.387656 [INFO ] .distance_mm:      [[[1217, 1711, 1858, 1946], [1746, 1804, 1837, 1908], [1747, 1768, 1841, 1894], [1736, 1778, 1852, 1911]], [[1542, 1653, 0, 0], [0, 726, 1963, 0], [0, 4042, 0, 524], [0, 0, 2247, 0]]]
5.387846 [INFO ] .reflectance:      [[[8, 65, 66, 74], [79, 80, 70, 66], [80, 72, 78, 57], [79, 70, 67, 70]], [[37, 45, 0, 0], [0, 2, 43, 0], [0, 57, 0, 1], [0, 0, 17, 0]]]
5.387989 [INFO ] End of ULD demo
```

That's a bunch of features!!!

You can steer the `m2` example's behaviour by the set of features you define. Equally, the `targets_per_zone_2` defines the "depth" of possibly separate targets, per zone, that the sensor will report.

>Playing with these will be more fun once we get graphical tools to show the data, instead of matrices.

Note how this change of behaviour of the code is steered by the Cargo `feature` system. It goes so deep that the *underlying ULD C API* gets compiled differently, omitting the features you don't state you are needing.

By leaving the `targets_per_zone_2` feature out, you will get only one data per zone (closest or strongest, depending on the source code; which seems to be favouring `CLOSEST`).


## Troubleshooting

### [ESP32-C3] I2C `TimeOut`

```
0.956520 [INFO ] Target powered off and on again.
0.960236 [DEBUG] Ping succeeded: 0xf0,0x02
1.522238 [ERROR] panicked at 'I2C write to 0x0bd0 (252 bytes) failed: TimeOut'
1.522361 [ERROR] ====================== PANIC ======================
```

This happens with **certain versions of `probe-rs`**.

- `0.24.0 (git commit: crates.io)` is bad
- the problem is [wont-fix](https://github.com/probe-rs/probe-rs/issues/2818#issuecomment-2358791448), unless they get news from Espressif

See [../README](../README.md) for instructions on how to install commit `6fee4b6` of `probe-rs` (latest revision with the hacks) + other alternatives.


### [ESP32-C3] No `defmt` output

```
$ probe-rs run --speed=200 --log-format '{t:dimmed} [{L:bold}] {s}' target/riscv32imc-unknown-none-elf/release/examples/multiboard
      Erasing ✔ [00:00:02] [################################] 256.00 KiB/256.00 KiB @ 112.53 KiB/s (eta 0s )
  Programming ✔ [00:00:33] [################################] 105.54 KiB/105.54 KiB @ 3.13 KiB/s (eta 0s )
    Finished in 33.767773s



```

This sometimes happens. Something is confused. This seems to resolve the situation:

- detach the USB cable of the device
- attach back
- `usbip attach -r ...` (if you are using USB/IP)
- try again


## Prior art

I had a look at these at the *early stages* of developing the repo. In addition, I've heard of a Rust adaptation that wasn't likely published.

- [`stm32duino/VL53L5CX`](https://github.com/stm32duino/VL53L5CX)

   *"Arduino library to support the VL53L5CX Time-of-Flight 8x8 multizone ranging sensor [...]"*

- [`RJRP44/VL53L5CX-Library`](https://github.com/RJRP44/VL53L5CX-Library/blob/master/README.md) (Jun'22 - Apr'24; BSD 3-clause license)

   *"A vl53l5cx library for esp32 using the esp-idf framework"*
   
- [`kriswiner/VL53L5CX`](https://github.com/kriswiner/VL53L5CX) (GitHub; 2021)
- [`simondlevy/VL53L5CX`](https://github.com/simondlevy/VL53L5CX) (GitHub; 2021)
	
	
## References

### VL53L5CX

- [Breakout Boards for VL53L5CX](https://www.st.com/en/evaluation-tools/vl53l5cx-satel.html) (ST.com)
- [Ultra Lite Driver (ULD) for VL53L5CX multi-zone sensor](https://www.st.com/en/embedded-software/stsw-img023.html) (ST.com)

	- ["Ultra lite driver (ULD) [...] with wide field of view"](https://www.st.com/resource/en/data_brief/stsw-img023.pdf) (PDF, May'21; 3pp)
	- ["A guide to using the VL53L5CX multizone [...]"](https://www.st.com/resource/en/user_manual/um2884-a-guide-to-using-the-vl53l5cx-multizone-timeofflight-ranging-sensor-with-a-wide-field-of-view-ultra-lite-driver-uld-stmicroelectronics.pdf) (PDF, revised Feb'24; 18pp)

		<font size=5 color=red>⇫</font> The main API usage guide

	- [Software licensing agreement](https://www.st.com/resource/en/license_agreement/dm00484327.pdf) (PDF, Feb'18; 5pp)

