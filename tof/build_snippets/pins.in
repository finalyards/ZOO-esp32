/*
* Helper for 'build.rs':es.
*
* Processes the 'pins.toml', producing a Rust snippet to be included in examples.
*
* Notes:
*   - do not use feature flags, though the 'SYNC' pin only exists for L8 (not L5CX). We *do* get
*     to see the features, but the IDE support is not there (since we are a loose snippet).
*
*   - favor scoped 'use' statements over root-level uses. The snippet is read verbatim to its place
*     of include, so any packages used here become available in the parent file.
*
* Design decisions:
*   - keeping away from OS commands and file system access. It's again more explicit when the
*     caller does this - even if it leads to duplication of such code (in both 'vl_uld' and 'vl_api').
*/
use anyhow::{Context, Result};
use std::collections::HashMap;

// TOML objects
//
#[derive(Debug, serde::Deserialize)]
struct PinsToml {
    boards: HashMap<String, HashMap<String,Board>>
}

#[derive(Debug, serde::Deserialize)]
#[allow(non_snake_case)]
struct Board {
    SDA: u32,
    SCL: u32,
    PWR_EN: u32,
    INT: u32,
    SYNC: Option<u32>,  // L8 only  // #dev: can be feature-flagged if we make the snippet into a proper project
    LPn: Vec<u32>,
}

#[allow(non_snake_case)]
fn process_pins(toml: &str, board_id: &str, sensor_id: &str) -> Result<String> {
    use itertools::Itertools;   // allows '.join()' on 'std::iter::Map'

    let c: PinsToml = toml::from_str(toml)?;

    let board = {
        c.boards.get(board_id).with_context(
            || format!("No section '[boards.{board_id}]' found in 'pins.toml'")
        )?
            .get(sensor_id).with_context(
            || format!("No section '[boards.{board_id}.{sensor_id}]' found in 'pins.toml'")
        )?
    };

    //|let board = {
    //|    let key = format!("{board_id}.{sensor_id}");
    //|    c.boards.get(&key).with_context(
    //|        || format!("No section '[boards.{key}]' found in 'pins.toml'")
    //|    )?
    //|};

    // unpack, because "field access not supported [...] in a format string"
    let Board { SDA, SCL, PWR_EN, INT, SYNC, LPn: LPns } = board;

    let ret = {
        #[allow(non_snake_case)]
        let LPns_len = LPns.len();
        let s_LPns = LPns.iter().map(|s| { format!("Pin::degrade( $peripherals.GPIO{s} )") })
            .join(", ");

        let s_SYNC: String = match SYNC {
            Some(pin) => format!("Some( $peripherals.GPIO{pin}.into() )"),
            None => "None".into()
        };

        format!(r#"// Generated by 'build.rs'
// DO NOT MAKE CHANGES HERE; THEY WILL GET LOST. Instead, edit 'pins.toml' and rebuild.
//
macro_rules! pins {{
    ($peripherals:ident) => {{{{
        use esp_hal::gpio::Pin;

        // {board_id}.{sensor_id}
        Pins {{
            SDA: $peripherals.GPIO{SDA}.into(),
            SCL: $peripherals.GPIO{SCL}.into(),
            PWR_EN: $peripherals.GPIO{PWR_EN}.into(),
            SYNC: {s_SYNC},
            INT: $peripherals.GPIO{INT}.into(),
            LPn: [{s_LPns}],
        }}
    }}}}
}}

#[allow(unused_macros)]
macro_rules! boards {{
    () => {{( {LPns_len} )}}
}}
"#)
    };

    Ok(ret)
}
