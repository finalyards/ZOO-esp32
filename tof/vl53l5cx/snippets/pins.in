// tbd. join these from different subfolders together (top level '/snippets'; worth some work since these are also custom.)
/*
* Helper for 'build.rs'
*
* Processes the 'pins.toml', injecting its contents - as Rust include - into the given path.
*
* This is 'include!'ed by 'build.rs', see -> https://doc.rust-lang.org/std/macro.include.html
*/
use anyhow::{Context, Result};
use serde::Deserialize;
use toml;
use itertools::Itertools;   // allows '.join()' on 'std::iter::Map'

use std::{
    collections::HashMap,
};

// TOML objects
//
#[derive(Debug, Deserialize)]
struct PinsToml {
    generate: String,
    boards: HashMap<String,Board>
}

#[derive(Debug, Deserialize)]
#[allow(non_snake_case)]
struct Board {
    SDA: u32,
    SCL: u32,
    PWR_EN: Option<u32>,
    INT: u32,   // same interrupt pin for all the boards
    LPn: Vec<u32>
}

#[allow(non_snake_case)]
fn process_pins(toml: &str, board_id: &str) -> Result<()> {
    let c: PinsToml = toml::from_str(toml)?;

    let board = c.boards.get(board_id).with_context(
        || format!("No section '[boards.{}]' found in 'pins.toml'", board_id)
    )?;

    let fn_ = &c.generate;
    assert!(fn_.len() > 0);

    // unpack, because "field access not supported [...] in a format string"
    let (SDA, SCL, PWR_EN, INT, LPns) = (board.SDA, board.SCL, board.PWR_EN, board.INT, &board.LPn);

    let contents = {
        let s_PWR_EN: String = match PWR_EN {
            None => "None".into(),
            Some(n) => format!("Some(O::new($io.pins.gpio{n}, L::Low))")
        };

        let LPns_len = LPns.len();
        let s_LPns: String = LPns.iter().map(|s| { format!("O::new($io.pins.gpio{s}, L::Low)") })
            .join(", ");

        format!(r#"// Generated by 'build.rs'
// DO NOT MAKE CHANGES HERE; THEY WILL GET LOST. Instead, edit 'pins.toml' and rebuild.
//
macro_rules! pins {{
    ($io:ident) => {{{{
        use esp_hal::{{ gpio::{{Output as O, Input as I, Level as L, Pull}} }};

        let x: (_, _, Option<O>, I, [O;{LPns_len}]) = (  // {board_id}
            $io.pins.gpio{SDA},
            $io.pins.gpio{SCL},
            {s_PWR_EN},
            I::new($io.pins.gpio{INT}, Pull::None),
            [{s_LPns}]
        );
        x
    }}}}
}}
"#)
    };

    fs::write(fn_, contents).with_context(
        || format!("Unable to write {fn_}")
    )?;

    Ok(())
}
