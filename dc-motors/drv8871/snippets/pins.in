/*
* Helper for 'build.rs'
*
* Processes the 'pins.toml', injecting its contents - as Rust include - into the given path.
*
* This is 'include!'ed by 'build.rs', see -> https://doc.rust-lang.org/std/macro.include.html
*/
use anyhow::{Context, Result};
use serde::Deserialize;
use toml;
use std::collections::HashMap;

// TOML objects
//
#[derive(Debug, Deserialize)]
struct PinsToml {
    generate: String,
    boards: HashMap<String,Board>
}

#[derive(Debug, Deserialize)]
#[allow(non_snake_case)]
struct Board {
    IN1: u32,
    IN2: u32,
    BTN: u32,
}

#[allow(non_snake_case)]
fn process_pins(toml: &str, board_id: &str) -> Result<()> {
    let c: PinsToml = toml::from_str(toml)?;

    let board = c.boards.get(board_id).with_context(
        || format!("No section '[boards.{}]' found in 'pins.toml'", board_id)
    )?;

    let filename = &c.generate;
    assert!(filename.len() > 0);

    // unpack, because "field access not supported [...] in a format string"
    let (IN1, IN2, BTN) = (board.IN1, board.IN2, board.BTN);

    let contents = format!(r#"// Generated by 'build.rs' (running 'cargo build').
// DO NOT MAKE CHANGES HERE; THEY WILL GET LOST. Instead, edit 'pins.toml' and rebuild.
//
macro_rules! pins {{
    ($io:ident) => {{{{
        let x: (_, _, _) = (  // {board_id}
            $io.pins.gpio{IN1},
            $io.pins.gpio{IN2},
            $io.pins.gpio{BTN},
        );
        x
    }}}}
}}

macro_rules! mcu {{
    ($io:ident) => {{{{
        "{board_id}"
    }}}}
}}
"#);

    fs::write(filename, contents).with_context(
        || format!("Unable to write {filename}")
    )?;

    Ok(())
}
